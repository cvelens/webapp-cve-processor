package main

import (
	"archive/zip"
	"bytes"
	"database/sql"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	_ "github.com/lib/pq"
)

type CVERecord struct {
	Containers struct {
		CNA struct {
			Affected []struct {
				Product  string `json:"product"`
				Vendor   string `json:"vendor"`
				Versions []struct {
					Status  string `json:"status"`
					Version string `json:"version"`
				} `json:"versions"`
			} `json:"affected"`
			Descriptions []struct {
				Lang  string `json:"lang"`
				Value string `json:"value"`
			} `json:"descriptions"`
			ProblemTypes []struct {
				Descriptions []struct {
					Description string `json:"description"`
					Lang        string `json:"lang"`
					Type        string `json:"type"`
				} `json:"descriptions"`
			} `json:"problemTypes"`
			ProviderMetadata struct {
				DateUpdated string `json:"dateUpdated"`
				OrgID       string `json:"orgId"`
				ShortName   string `json:"shortName"`
			} `json:"providerMetadata"`
			References []struct {
				Name string   `json:"name"`
				Tags []string `json:"tags"`
				URL  string   `json:"url"`
			} `json:"references"`
			XLegacyV4Record struct {
				CVEDataMeta struct {
					Assigner string `json:"ASSIGNER"`
					ID       string `json:"ID"`
					State    string `json:"STATE"`
				} `json:"CVE_data_meta"`
				Affects struct {
					Vendor struct {
						VendorData []struct {
							Product struct {
								ProductData []struct {
									ProductName string `json:"product_name"`
									Version     struct {
										VersionData []struct {
											VersionValue string `json:"version_value"`
										} `json:"version_data"`
									} `json:"version"`
								} `json:"product_data"`
							} `json:"product"`
							VendorName string `json:"vendor_name"`
						} `json:"vendor_data"`
					} `json:"vendor"`
				} `json:"affects"`
				DataFormat  string `json:"data_format"`
				DataType    string `json:"data_type"`
				DataVersion string `json:"data_version"`
				Description struct {
					DescriptionData []struct {
						Lang  string `json:"lang"`
						Value string `json:"value"`
					} `json:"description_data"`
				} `json:"description"`
				ProblemType struct {
					ProblemTypeData []struct {
						Description []struct {
							Lang  string `json:"lang"`
							Value string `json:"value"`
						} `json:"description"`
					} `json:"problemtype_data"`
				} `json:"problemtype"`
				References struct {
					ReferenceData []struct {
						Name      string `json:"name"`
						Refsource string `json:"refsource"`
						URL       string `json:"url"`
					} `json:"reference_data"`
				} `json:"references"`
			} `json:"x_legacyV4Record"`
		} `json:"cna"`
	} `json:"containers"`
	CveMetadata struct {
		AssignerOrgID     string `json:"assignerOrgId"`
		AssignerShortName string `json:"assignerShortName"`
		CveID             string `json:"cveId"`
		DatePublished     string `json:"datePublished"`
		DateReserved      string `json:"dateReserved"`
		DateUpdated       string `json:"dateUpdated"`
		State             string `json:"state"`
	} `json:"cveMetadata"`
	DataType    string `json:"dataType"`
	DataVersion string `json:"dataVersion"`
}

const (
	host     = "localhost"
	port     = 5432
	user     = "postgres"
	password = "admin"
	dbname   = "cve"
)

func main() {

	psqlInfo := fmt.Sprintf("host=%s port=%d user=%s "+
		"password=%s dbname=%s sslmode=disable",
		host, port, user, password, dbname)

	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		log.Fatalf("Error opening database: %v\n", err)
	}
	defer db.Close()

	err = db.Ping()
	if err != nil {
		fmt.Println("Database does not exist, creating")
		defaultDbInfo := fmt.Sprintf("host=%s port=%d user=%s "+
			"password=%s dbname=postgres sslmode=disable",
			host, port, user, password)

		defaultDb, err := sql.Open("postgres", defaultDbInfo)
		if err != nil {
			log.Fatalf("Error opening default database: %v\n", err)
		}
		defer defaultDb.Close()

		_, err = defaultDb.Exec(fmt.Sprintf("CREATE DATABASE %s", dbname))
		if err != nil {
			log.Fatalf("Error creating database: %v\n", err)
		}

		fmt.Println("Database created successfully, now connecting")

		db, err = sql.Open("postgres", psqlInfo)
		if err != nil {
			log.Fatalf("Error opening new database: %v\n", err)
		}
		defer db.Close()

		err = db.Ping()
		if err != nil {
			log.Fatalf("Error pinging new database: %v\n", err)
		}
	}

	fmt.Println("Successfully connected!")

	// Create the "cve" schema if it doesn't exist
	_, err = db.Exec(`CREATE SCHEMA IF NOT EXISTS cve`)
	if err != nil {
		fmt.Println("Error creating cve schema:", err)
		os.Exit(1)
	}

	err = downloadCVEData()
	if err != nil {
		fmt.Println("Error downloading CVE data:", err)
		os.Exit(1)
	}

	// Create the cve table if it doesn't exist in the "cve" schema
	_, err = db.Exec(`
		CREATE TABLE IF NOT EXISTS cve.cve (
			id TEXT,
			version INTEGER,
			assigner_org_id TEXT,
			assigner_short_name TEXT,
			date_published TEXT,
			date_reserved TEXT,
			date_updated TEXT,
			state TEXT,
			data JSONB,
			created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
			PRIMARY KEY (id, version)
		)
	`)
	if err != nil {
		fmt.Println("Error creating cve table:", err)
		os.Exit(1)
	} else {
		fmt.Println("cve table created successfully")
	}

	// Check if the cve table exists in the "cve" schema
	var tableExists bool
	err = db.QueryRow("SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'cve' AND table_name = 'cve')").Scan(&tableExists)
	if err != nil {
		fmt.Println("Error checking if cve table exists:", err)
		os.Exit(1)
	}
	if !tableExists {
		fmt.Println("cve table does not exist in the cve schema")
		os.Exit(1)
	}

	// Open the cve_data.zip file
	zipFile, err := zip.OpenReader("cve_data.zip")
	if err != nil {
		fmt.Println("Error opening cve_data.zip:", err)
		os.Exit(1)
	}
	defer zipFile.Close()

	totalFiles := len(zipFile.File)
	processedFiles := 0
	startTime := time.Now()

	fmt.Printf("Total CVE JSON files found: %d\n", totalFiles)
	fmt.Println("Processing CVE JSON files...")

	_, err = db.Exec(`
		CREATE TABLE IF NOT EXISTS cve.processed_files (
			file_name TEXT PRIMARY KEY
		)
	`)
	if err != nil {
		fmt.Println("Error creating processed_files table:", err)
		os.Exit(1)
	}

	// Process CVE JSON files from the zip archive
	for _, file := range zipFile.File {
		if strings.HasSuffix(file.Name, ".json") {
			// Skip delta.json and deltaLog.json files
			if strings.HasSuffix(file.Name, "delta.json") || strings.HasSuffix(file.Name, "deltaLog.json") {
				continue
			}

			// Open the JSON file inside the zip archive
			jsonFile, err := file.Open()
			if err != nil {
				fmt.Println("Error opening JSON file:", file.Name, err)
				continue
			}
			defer jsonFile.Close()

			// Read the JSON file contents
			data, err := io.ReadAll(jsonFile)
			if err != nil {
				fmt.Println("Error reading JSON file:", file.Name, err)
				continue
			}

			var processed bool
			err = db.QueryRow("SELECT EXISTS(SELECT 1 FROM cve.processed_files WHERE file_name = $1)", file.Name).Scan(&processed)
			if err != nil {
				fmt.Printf("Error checking if file %s has been processed: %v\n", file.Name, err)
				continue
			}

			if processed {
				fmt.Printf("File %s has already been processed. Skipping.\n", file.Name)
				continue
			}

			// Parse the CVE JSON data
			var cveRecord CVERecord
			err = json.Unmarshal(data, &cveRecord)

			if err != nil {
				fmt.Println("Error parsing CVE JSON data:", file.Name, err)
				continue
			}

			// Check if the CVE record already exists
			var existingData []byte
			err = db.QueryRow("SELECT data FROM cve.cve WHERE id = $1 ORDER BY version DESC LIMIT 1", cveRecord.CveMetadata.CveID).Scan(&existingData)
			if err != nil && err != sql.ErrNoRows {
				fmt.Printf("Error checking existence of CVE record %s: %v\n", cveRecord.CveMetadata.CveID, err)
				continue
			}

			if len(existingData) > 0 {
				// Compare the existing data with the current data
				if bytes.Equal(existingData, data) {
					fmt.Printf("CVE record %s already exists with the same data. Skipping insertion.\n", cveRecord.CveMetadata.CveID)
					continue
				}

				// If the data is different, increment the version and insert the updated record
				var existingVersion int
				err = db.QueryRow("SELECT version FROM cve.cve WHERE id = $1 ORDER BY version DESC LIMIT 1", cveRecord.CveMetadata.CveID).Scan(&existingVersion)
				if err != nil {
					fmt.Printf("Error retrieving existing version for CVE record %s: %v\n", cveRecord.CveMetadata.CveID, err)
					continue
				}

				newVersion := existingVersion + 1

				// _, err = db.Exec(`
				// 	INSERT INTO cve (id, assigner_org_id, assigner_short_name, date_published, date_reserved, date_updated, state, data)
				// 	VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
				// 	ON CONFLICT (id) DO UPDATE SET
				// 		assigner_org_id = EXCLUDED.assigner_org_id,
				// 		assigner_short_name = EXCLUDED.assigner_short_name,
				// 		date_published = EXCLUDED.date_published,
				// 		date_reserved = EXCLUDED.date_reserved,
				// 		date_updated = EXCLUDED.date_updated,
				// 		state = EXCLUDED.state,
				// 		data = EXCLUDED.data
				// `, cveRecord.CveMetadata.CveID, cveRecord.CveMetadata.AssignerOrgID, cveRecord.CveMetadata.AssignerShortName, cveRecord.CveMetadata.DatePublished, cveRecord.CveMetadata.DateReserved, cveRecord.CveMetadata.DateUpdated, cveRecord.CveMetadata.State, data)

				// Insert the new version of the CVE record
				_, err = db.Exec(`
					INSERT INTO cve.cve (id, version, assigner_org_id, assigner_short_name, date_published, date_reserved, date_updated, state, data)
					VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
				`, cveRecord.CveMetadata.CveID, newVersion, cveRecord.CveMetadata.AssignerOrgID, cveRecord.CveMetadata.AssignerShortName, cveRecord.CveMetadata.DatePublished, cveRecord.CveMetadata.DateReserved, cveRecord.CveMetadata.DateUpdated, cveRecord.CveMetadata.State, data)

				if err != nil {
					fmt.Printf("Error inserting updated CVE record %s (version %d): %v\n", cveRecord.CveMetadata.CveID, newVersion, err)
				}
			} else {
				// If the CVE record doesn't exist, insert it with version 1
				_, err = db.Exec(`
					INSERT INTO cve.cve (id, version, assigner_org_id, assigner_short_name, date_published, date_reserved, date_updated, state, data)
					VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
				`, cveRecord.CveMetadata.CveID, 1, cveRecord.CveMetadata.AssignerOrgID, cveRecord.CveMetadata.AssignerShortName, cveRecord.CveMetadata.DatePublished, cveRecord.CveMetadata.DateReserved, cveRecord.CveMetadata.DateUpdated, cveRecord.CveMetadata.State, data)

				if err != nil {
					fmt.Printf("Error inserting new CVE record %s: %v\n", cveRecord.CveMetadata.CveID, err)
				}
			}

			_, err = db.Exec("INSERT INTO cve.processed_files (file_name) VALUES ($1)", file.Name)
			if err != nil {
				fmt.Printf("Error inserting file %s into processed_files table: %v\n", file.Name, err)
			}

			processedFiles++
			if processedFiles%1000 == 0 {
				elapsedTime := time.Since(startTime)
				fmt.Printf("Processed %d out of %d files (%.2f%%) in %s\n", processedFiles, totalFiles, float64(processedFiles)/float64(totalFiles)*100, elapsedTime)
			}

		}
	}

	elapsedTime := time.Since(startTime)
	fmt.Printf("CVE record processing completed. Total files processed: %d\n", processedFiles)
	fmt.Printf("Total processing time: %s\n", elapsedTime)

}

func downloadCVEData() error {
	url := "https://github.com/CVEProject/cvelistV5/archive/refs/heads/main.zip"
	zipFileName := "cve_data.zip"

	// Create the file
	out, err := os.Create(zipFileName)
	if err != nil {
		return err
	}
	defer out.Close()

	// Download the ZIP file
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Write the ZIP file to disk
	_, err = io.Copy(out, resp.Body)
	if err != nil {
		return err
	}

	return nil
}
